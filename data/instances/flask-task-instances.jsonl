{"repo": "pallets/flask", "pull_number": 4074, "instance_id": "pallets__flask-4074", "issue_numbers": ["1091"], "base_commit": "a541c2ac8b05c2b23e11bd8540088fce1abc2373", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -27,6 +27,14 @@ Unreleased\n     removed early. :issue:`4078`\n -   Improve typing for some functions using ``Callable`` in their type\n     signatures, focusing on decorator factories. :issue:`4060`\n+-   Nested blueprints are registered with their dotted name. This allows\n+    different blueprints with the same name to be nested at different\n+    locations. :issue:`4069`\n+-   ``register_blueprint`` takes a ``name`` option to change the\n+    (pre-dotted) name the blueprint is registered with. This allows the\n+    same blueprint to be registered multiple times with unique names for\n+    ``url_for``. Registering the same blueprint with the same name\n+    multiple times is deprecated. :issue:`1091`\n \n \n Version 2.0.0\ndiff --git a/src/flask/app.py b/src/flask/app.py\n--- a/src/flask/app.py\n+++ b/src/flask/app.py\n@@ -36,6 +36,7 @@\n from .globals import g\n from .globals import request\n from .globals import session\n+from .helpers import _split_blueprint_path\n from .helpers import get_debug_flag\n from .helpers import get_env\n from .helpers import get_flashed_messages\n@@ -747,7 +748,7 @@ def update_template_context(self, context: dict) -> None:\n         ] = self.template_context_processors[None]\n         reqctx = _request_ctx_stack.top\n         if reqctx is not None:\n-            for bp in self._request_blueprints():\n+            for bp in request.blueprints:\n                 if bp in self.template_context_processors:\n                     funcs = chain(funcs, self.template_context_processors[bp])\n         orig_ctx = context.copy()\n@@ -1018,6 +1019,12 @@ def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n             :class:`~flask.blueprints.BlueprintSetupState`. They can be\n             accessed in :meth:`~flask.Blueprint.record` callbacks.\n \n+        .. versionchanged:: 2.0.1\n+            The ``name`` option can be used to change the (pre-dotted)\n+            name the blueprint is registered with. This allows the same\n+            blueprint to be registered multiple times with unique names\n+            for ``url_for``.\n+\n         .. versionadded:: 0.7\n         \"\"\"\n         blueprint.register(self, options)\n@@ -1267,7 +1274,7 @@ def _find_error_handler(self, e: Exception) -> t.Optional[ErrorHandlerCallable]:\n         exc_class, code = self._get_exc_class_and_code(type(e))\n \n         for c in [code, None]:\n-            for name in chain(self._request_blueprints(), [None]):\n+            for name in chain(request.blueprints, [None]):\n                 handler_map = self.error_handler_spec[name][c]\n \n                 if not handler_map:\n@@ -1788,9 +1795,14 @@ def inject_url_defaults(self, endpoint: str, values: dict) -> None:\n         .. versionadded:: 0.7\n         \"\"\"\n         funcs: t.Iterable[URLDefaultCallable] = self.url_default_functions[None]\n+\n         if \".\" in endpoint:\n-            bp = endpoint.rsplit(\".\", 1)[0]\n-            funcs = chain(funcs, self.url_default_functions[bp])\n+            # This is called by url_for, which can be called outside a\n+            # request, can't use request.blueprints.\n+            bps = _split_blueprint_path(endpoint.rpartition(\".\")[0])\n+            bp_funcs = chain.from_iterable(self.url_default_functions[bp] for bp in bps)\n+            funcs = chain(funcs, bp_funcs)\n+\n         for func in funcs:\n             func(endpoint, values)\n \n@@ -1831,14 +1843,14 @@ def preprocess_request(self) -> t.Optional[ResponseReturnValue]:\n         funcs: t.Iterable[URLValuePreprocessorCallable] = self.url_value_preprocessors[\n             None\n         ]\n-        for bp in self._request_blueprints():\n+        for bp in request.blueprints:\n             if bp in self.url_value_preprocessors:\n                 funcs = chain(funcs, self.url_value_preprocessors[bp])\n         for func in funcs:\n             func(request.endpoint, request.view_args)\n \n         funcs: t.Iterable[BeforeRequestCallable] = self.before_request_funcs[None]\n-        for bp in self._request_blueprints():\n+        for bp in request.blueprints:\n             if bp in self.before_request_funcs:\n                 funcs = chain(funcs, self.before_request_funcs[bp])\n         for func in funcs:\n@@ -1863,7 +1875,7 @@ def process_response(self, response: Response) -> Response:\n         \"\"\"\n         ctx = _request_ctx_stack.top\n         funcs: t.Iterable[AfterRequestCallable] = ctx._after_request_functions\n-        for bp in self._request_blueprints():\n+        for bp in request.blueprints:\n             if bp in self.after_request_funcs:\n                 funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n         if None in self.after_request_funcs:\n@@ -1902,7 +1914,7 @@ def do_teardown_request(\n         funcs: t.Iterable[TeardownCallable] = reversed(\n             self.teardown_request_funcs[None]\n         )\n-        for bp in self._request_blueprints():\n+        for bp in request.blueprints:\n             if bp in self.teardown_request_funcs:\n                 funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n         for func in funcs:\n@@ -2074,9 +2086,3 @@ def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:\n         wrapped to apply middleware.\n         \"\"\"\n         return self.wsgi_app(environ, start_response)\n-\n-    def _request_blueprints(self) -> t.Iterable[str]:\n-        if _request_ctx_stack.top.request.blueprint is None:\n-            return []\n-        else:\n-            return reversed(_request_ctx_stack.top.request.blueprint.split(\".\"))\ndiff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -67,6 +67,7 @@ def __init__(\n         #: blueprint.\n         self.url_prefix = url_prefix\n \n+        self.name = self.options.get(\"name\", blueprint.name)\n         self.name_prefix = self.options.get(\"name_prefix\", \"\")\n \n         #: A dictionary with URL defaults that is added to each and every\n@@ -96,9 +97,10 @@ def add_url_rule(\n         defaults = self.url_defaults\n         if \"defaults\" in options:\n             defaults = dict(defaults, **options.pop(\"defaults\"))\n+\n         self.app.add_url_rule(\n             rule,\n-            f\"{self.name_prefix}{self.blueprint.name}.{endpoint}\",\n+            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n             view_func,\n             defaults=defaults,\n             **options,\n@@ -252,8 +254,16 @@ def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n         arguments passed to this method will override the defaults set\n         on the blueprint.\n \n+        .. versionchanged:: 2.0.1\n+            The ``name`` option can be used to change the (pre-dotted)\n+            name the blueprint is registered with. This allows the same\n+            blueprint to be registered multiple times with unique names\n+            for ``url_for``.\n+\n         .. versionadded:: 2.0\n         \"\"\"\n+        if blueprint is self:\n+            raise ValueError(\"Cannot register a blueprint on itself\")\n         self._blueprints.append((blueprint, options))\n \n     def register(self, app: \"Flask\", options: dict) -> None:\n@@ -266,23 +276,48 @@ def register(self, app: \"Flask\", options: dict) -> None:\n             with.\n         :param options: Keyword arguments forwarded from\n             :meth:`~Flask.register_blueprint`.\n-        :param first_registration: Whether this is the first time this\n-            blueprint has been registered on the application.\n+\n+        .. versionchanged:: 2.0.1\n+            Nested blueprints are registered with their dotted name.\n+            This allows different blueprints with the same name to be\n+            nested at different locations.\n+\n+        .. versionchanged:: 2.0.1\n+            The ``name`` option can be used to change the (pre-dotted)\n+            name the blueprint is registered with. This allows the same\n+            blueprint to be registered multiple times with unique names\n+            for ``url_for``.\n+\n+        .. versionchanged:: 2.0.1\n+            Registering the same blueprint with the same name multiple\n+            times is deprecated and will become an error in Flask 2.1.\n         \"\"\"\n-        first_registration = False\n-\n-        if self.name in app.blueprints:\n-            assert app.blueprints[self.name] is self, (\n-                \"A name collision occurred between blueprints\"\n-                f\" {self!r} and {app.blueprints[self.name]!r}.\"\n-                f\" Both share the same name {self.name!r}.\"\n-                f\" Blueprints that are created on the fly need unique\"\n-                f\" names.\"\n-            )\n-        else:\n-            app.blueprints[self.name] = self\n-            first_registration = True\n+        first_registration = not any(bp is self for bp in app.blueprints.values())\n+        name_prefix = options.get(\"name_prefix\", \"\")\n+        self_name = options.get(\"name\", self.name)\n+        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n+\n+        if name in app.blueprints:\n+            existing_at = f\" '{name}'\" if self_name != name else \"\"\n+\n+            if app.blueprints[name] is not self:\n+                raise ValueError(\n+                    f\"The name '{self_name}' is already registered for\"\n+                    f\" a different blueprint{existing_at}. Use 'name='\"\n+                    \" to provide a unique name.\"\n+                )\n+            else:\n+                import warnings\n+\n+                warnings.warn(\n+                    f\"The name '{self_name}' is already registered for\"\n+                    f\" this blueprint{existing_at}. Use 'name=' to\"\n+                    \" provide a unique name. This will become an error\"\n+                    \" in Flask 2.1.\",\n+                    stacklevel=4,\n+                )\n \n+        app.blueprints[name] = self\n         self._got_registered_once = True\n         state = self.make_setup_state(app, options, first_registration)\n \n@@ -298,12 +333,11 @@ def register(self, app: \"Flask\", options: dict) -> None:\n \n             def extend(bp_dict, parent_dict):\n                 for key, values in bp_dict.items():\n-                    key = self.name if key is None else f\"{self.name}.{key}\"\n-\n+                    key = name if key is None else f\"{name}.{key}\"\n                     parent_dict[key].extend(values)\n \n             for key, value in self.error_handler_spec.items():\n-                key = self.name if key is None else f\"{self.name}.{key}\"\n+                key = name if key is None else f\"{name}.{key}\"\n                 value = defaultdict(\n                     dict,\n                     {\n@@ -337,7 +371,7 @@ def extend(bp_dict, parent_dict):\n             if cli_resolved_group is None:\n                 app.cli.commands.update(self.cli.commands)\n             elif cli_resolved_group is _sentinel:\n-                self.cli.name = self.name\n+                self.cli.name = name\n                 app.cli.add_command(self.cli)\n             else:\n                 self.cli.name = cli_resolved_group\n@@ -354,10 +388,12 @@ def extend(bp_dict, parent_dict):\n                 bp_options[\"url_prefix\"] = (\n                     state.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n                 )\n-            else:\n+            elif bp_url_prefix is not None:\n+                bp_options[\"url_prefix\"] = bp_url_prefix\n+            elif state.url_prefix is not None:\n                 bp_options[\"url_prefix\"] = state.url_prefix\n \n-            bp_options[\"name_prefix\"] = options.get(\"name_prefix\", \"\") + self.name + \".\"\n+            bp_options[\"name_prefix\"] = name\n             blueprint.register(app, bp_options)\n \n     def add_url_rule(\ndiff --git a/src/flask/helpers.py b/src/flask/helpers.py\n--- a/src/flask/helpers.py\n+++ b/src/flask/helpers.py\n@@ -6,6 +6,7 @@\n import warnings\n from datetime import datetime\n from datetime import timedelta\n+from functools import lru_cache\n from functools import update_wrapper\n from threading import RLock\n \n@@ -821,3 +822,13 @@ def is_ip(value: str) -> bool:\n             return True\n \n     return False\n+\n+\n+@lru_cache(maxsize=None)\n+def _split_blueprint_path(name: str) -> t.List[str]:\n+    out: t.List[str] = [name]\n+\n+    if \".\" in name:\n+        out.extend(_split_blueprint_path(name.rpartition(\".\")[0]))\n+\n+    return out\ndiff --git a/src/flask/wrappers.py b/src/flask/wrappers.py\n--- a/src/flask/wrappers.py\n+++ b/src/flask/wrappers.py\n@@ -6,6 +6,7 @@\n \n from . import json\n from .globals import current_app\n+from .helpers import _split_blueprint_path\n \n if t.TYPE_CHECKING:\n     import typing_extensions as te\n@@ -59,23 +60,54 @@ def max_content_length(self) -> t.Optional[int]:  # type: ignore\n \n     @property\n     def endpoint(self) -> t.Optional[str]:\n-        \"\"\"The endpoint that matched the request.  This in combination with\n-        :attr:`view_args` can be used to reconstruct the same or a\n-        modified URL.  If an exception happened when matching, this will\n-        be ``None``.\n+        \"\"\"The endpoint that matched the request URL.\n+\n+        This will be ``None`` if matching failed or has not been\n+        performed yet.\n+\n+        This in combination with :attr:`view_args` can be used to\n+        reconstruct the same URL or a modified URL.\n         \"\"\"\n         if self.url_rule is not None:\n             return self.url_rule.endpoint\n-        else:\n-            return None\n+\n+        return None\n \n     @property\n     def blueprint(self) -> t.Optional[str]:\n-        \"\"\"The name of the current blueprint\"\"\"\n-        if self.url_rule and \".\" in self.url_rule.endpoint:\n-            return self.url_rule.endpoint.rsplit(\".\", 1)[0]\n-        else:\n-            return None\n+        \"\"\"The registered name of the current blueprint.\n+\n+        This will be ``None`` if the endpoint is not part of a\n+        blueprint, or if URL matching failed or has not been performed\n+        yet.\n+\n+        This does not necessarily match the name the blueprint was\n+        created with. It may have been nested, or registered with a\n+        different name.\n+        \"\"\"\n+        endpoint = self.endpoint\n+\n+        if endpoint is not None and \".\" in endpoint:\n+            return endpoint.rpartition(\".\")[0]\n+\n+        return None\n+\n+    @property\n+    def blueprints(self) -> t.List[str]:\n+        \"\"\"The registered names of the current blueprint upwards through\n+        parent blueprints.\n+\n+        This will be an empty list if there is no current blueprint, or\n+        if URL matching failed.\n+\n+        .. versionadded:: 2.0.1\n+        \"\"\"\n+        name = self.blueprint\n+\n+        if name is None:\n+            return []\n+\n+        return _split_blueprint_path(name)\n \n     def _load_form_data(self) -> None:\n         RequestBase._load_form_data(self)\n", "test_patch": "diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -140,7 +140,7 @@ def bar(bar):\n         return str(bar)\n \n     app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n-    app.register_blueprint(bp, url_prefix=\"/2\", url_defaults={\"bar\": 19})\n+    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n \n     assert client.get(\"/1/foo\").data == b\"23/42\"\n     assert client.get(\"/2/foo\").data == b\"19/42\"\n@@ -837,48 +837,77 @@ def grandchild_no():\n     assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n \n \n-def test_nested_blueprint_url_prefix(app, client):\n-    parent = flask.Blueprint(\"parent\", __name__, url_prefix=\"/parent\")\n-    child = flask.Blueprint(\"child\", __name__, url_prefix=\"/child\")\n-    grandchild = flask.Blueprint(\"grandchild\", __name__, url_prefix=\"/grandchild\")\n-    apple = flask.Blueprint(\"apple\", __name__, url_prefix=\"/apple\")\n-\n-    @parent.route(\"/\")\n-    def parent_index():\n-        return \"Parent\"\n+@pytest.mark.parametrize(\n+    \"parent_init, child_init, parent_registration, child_registration\",\n+    [\n+        (\"/parent\", \"/child\", None, None),\n+        (\"/parent\", None, None, \"/child\"),\n+        (None, None, \"/parent\", \"/child\"),\n+        (\"/other\", \"/something\", \"/parent\", \"/child\"),\n+    ],\n+)\n+def test_nesting_url_prefixes(\n+    parent_init,\n+    child_init,\n+    parent_registration,\n+    child_registration,\n+    app,\n+    client,\n+) -> None:\n+    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n+    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n \n     @child.route(\"/\")\n-    def child_index():\n-        return \"Child\"\n+    def index():\n+        return \"index\"\n \n-    @grandchild.route(\"/\")\n-    def grandchild_index():\n-        return \"Grandchild\"\n+    parent.register_blueprint(child, url_prefix=child_registration)\n+    app.register_blueprint(parent, url_prefix=parent_registration)\n \n-    @apple.route(\"/\")\n-    def apple_index():\n-        return \"Apple\"\n+    response = client.get(\"/parent/child/\")\n+    assert response.status_code == 200\n \n-    child.register_blueprint(grandchild)\n-    child.register_blueprint(apple, url_prefix=\"/orange\")  # test overwrite\n-    parent.register_blueprint(child)\n-    app.register_blueprint(parent)\n \n-    assert client.get(\"/parent/\").data == b\"Parent\"\n-    assert client.get(\"/parent/child/\").data == b\"Child\"\n-    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild\"\n-    assert client.get(\"/parent/child/orange/\").data == b\"Apple\"\n+def test_unique_blueprint_names(app, client) -> None:\n+    bp = flask.Blueprint(\"bp\", __name__)\n+    bp2 = flask.Blueprint(\"bp\", __name__)\n \n+    app.register_blueprint(bp)\n \n-def test_nested_blueprint_url_prefix_only_parent_prefix(app, client):\n-    parent = flask.Blueprint(\"parent\", __name__)\n-    child = flask.Blueprint(\"child\", __name__)\n+    with pytest.warns(UserWarning):\n+        app.register_blueprint(bp)  # same bp, same name, warning\n \n-    @child.route(\"/child-endpoint\")\n-    def child_index():\n-        return \"Child\"\n+    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n \n-    parent.register_blueprint(child)\n-    app.register_blueprint(parent, url_prefix=\"/parent\")\n+    with pytest.raises(ValueError):\n+        app.register_blueprint(bp2)  # different bp, same name, error\n+\n+    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n+\n+\n+def test_self_registration(app, client) -> None:\n+    bp = flask.Blueprint(\"bp\", __name__)\n+    with pytest.raises(ValueError):\n+        bp.register_blueprint(bp)\n+\n+\n+def test_blueprint_renaming(app, client) -> None:\n+    bp = flask.Blueprint(\"bp\", __name__)\n+    bp2 = flask.Blueprint(\"bp2\", __name__)\n+\n+    @bp.get(\"/\")\n+    def index():\n+        return flask.request.endpoint\n+\n+    @bp2.get(\"/\")\n+    def index2():\n+        return flask.request.endpoint\n+\n+    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n+    app.register_blueprint(bp, url_prefix=\"/a\")\n+    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n \n-    assert client.get(\"/parent/child-endpoint\").data == b\"Child\"\n+    assert client.get(\"/a/\").data == b\"bp.index\"\n+    assert client.get(\"/b/\").data == b\"alt.index\"\n+    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n+    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n", "problem_statement": "url_for can't distinguish a blueprint mounted two times\nBased on blueprint concept, I expected it to handle relative `url_for` nicely:\n\n```\nfrom flask import Blueprint, Flask, url_for\n\nbp = Blueprint('foo', __name__)\n\n@bp.route('/')\ndef func():\n    return url_for('.func')\n\napp = Flask(__name__)\napp.register_blueprint(bp, url_prefix='/foo')\napp.register_blueprint(bp, url_prefix='/bar')\n\nclient = app.test_client()\nprint client.get('/foo/').data\nprint client.get('/bar/').data\n```\n\nBoth prints write the URL to the first blueprint registered (`/foo/`). Is it possible to mount two times the same blueprint and make relative `url_for` work? Is this behaviour expected?\n\n", "hints_text": "@iurisilvio this is expected behaviour. It won't work with absolute name (i.e. `blueprint_name.func`) either. What are you trying to do exactly? Probably you should use `request.url` instead of `url_for`.\n\n@jackunion it was just an example. I want to mount the same blueprint with different prefixes and I expect my _relative_ `url_for` to work inside my blueprint, but this is not how it works.\n\nI fixed my problem with multiple blueprints (with the same routes), but I expected `url_for` working fine with blueprints.\n\nFlask store the blueprint in a dict like `dict[blueprint.name] = blueprint`. I can change the blueprint name before register the blueprint again and it works (or override the `app.register_blueprint` to avoid name collision). I'm not sure if it really works.\n\n@iurisilvio actually, `url_for` works just fine :]\nTry `print(app.url_map)` to see all url rules.\n\nI am really curious what you're trying to do with registering the same blueprint multiple times. The restriction might seem arbitrary, but i can imagine it is in place to avoid gross misuse of Flask's blueprints.\n\n> Register a blueprint multiple times on an application with different URL rules.\n\nFrom http://flask.pocoo.org/docs/blueprints/\n\n> @iurisilvio this is expected behaviour. It won't work with absolute name (i.e. blueprint_name.func) either.\n\nThat is not true. This is not expected behaviour, this is a supported use case.\n\n@danielchatfield have you read the question?\n\nYes. The docs give registering a single blueprint multiple times on the same app as an \"intended use case\".\n\nThe utility of that is somewhat questionable if `url_for` doesn't work properly.\n\n@untitaker I have a blueprint mounted in `/foo`, but I also want almost the same views in routes like  `/x/foo` and `/y/foo`, where `x` and `y` are sections of my app. Some users can view only `x` section, which contains lots of routes from other blueprints too. Other users can view `x`, `y` and the `/foo`, which contains data from both sections and some other things.\n\nIn most cases, I'd prefer `/something/x` and `/something/y`, but this is not the case, `x` and `y` are used in several parts of my app and really makes sense in this case.\n\nI just created a blueprint factory to fix this issue for me, using different names. It works fine and is not a huge problem for me. But I consider it a bug, because it is an intended use case (@danielchatfield already quoted it). I never expected a relative `url_for` returning something from other mounted blueprint.\n\nFirst, i have to admit that it indeed seems to be an intended usecase.\n\n @iurisilvio It basically seems like you're mixing code and data there. Adding a rule `/<section>/foo` and using a proper data storage for the sections seems better at first glance, but i don't want to say your solution is wrong since i don't know your usecase.\n\nYes, I agree. This structure is weird, but it is really the right choice for my app.\n\nAs I said, it was easy to workaround this issue, but if I rather mount the same blueprint in different paths. Blueprints are perfect to my use case, based on blueprint definition. Unfortunately, `url_for` breaks all my url references. Looks like a bug or at least docs deserve better explanation about this limitation.\n\n@danielchatfield this question is about `url_for`, not about registering multiple blueprints.\n\n@jackunion this issue is about the `url_for` behaviour with the same blueprint registered more than once.\n\nTwo statements from blueprints docs:\n\n> Register a blueprint multiple times on an application with different URL rules.\n> \n> Additionally if you are in a view function of a blueprint or a rendered template and you want to link to another endpoint of the same blueprint, you can use relative redirects by prefixing the endpoint with a dot only\n\n@iurisilvio and again:\n`url_for` will not work as you expect even with absolute name (i.e. blueprint_name.view_func), not only with relative name.\nIt will give you the wrong url even if your blueprint is registered once but have more than one route decorator (i.e `@blueprint_name.route()`).\nIf you want to know how exactly `url_for` builds url, start [here](https://github.com/mitsuhiko/flask/blob/master/flask/helpers.py#L186).\n\n@jackunion the point of this issue is that it is a bug.\n\n@jackunion we know it doesn't work, but as per the docs it should work!\n\nHmm, this is definitely unexpected behavior, but I'm not sure what we can do about it. The problem is that the endpoint becomes `foo.func`, and while Werkzeug knows all the rules associated with an endpoint, it only uses the first one to build with.\r\n\r\nThere's no information about which path to prefer. We'd need to send the url prefix to `MapAdapter.build` and use that when deciding which rule to use for the endpoint.\r\n\r\nThere's also no way to know what other prefixes a blueprint was registered under, so we can't know a prefix to strip and replace with the current blueprint.\nThis is really confusing. The same `Register a blueprint multiple times on an application with different URL rules` line in the docs let me to expect that utilities like `url_for` would still work, but they don't.\r\n\r\nMy solution was to just nest my blueprint creation and route definition inside a `make_blueprint(blueprint_name)` factory function that could pass different `name` parameters to each `Blueprint` instance ...", "created_at": "2021-05-18T12:40:47Z"}
{"repo": "pallets/flask", "pull_number": 4544, "instance_id": "pallets__flask-4544", "issue_numbers": ["4459"], "base_commit": "dba2be9311d2abfd1b973c6bb578f416ee771fda", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -7,6 +7,8 @@ Unreleased\n \n -   Fix type annotation for ``json.loads``, it accepts str or bytes.\n     :issue:`4519`\n+-   The ``--cert`` and ``--key`` options on ``flask run`` can be given\n+    in either order. :issue:`4459`\n \n \n Version 2.1.1\ndiff --git a/src/flask/cli.py b/src/flask/cli.py\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -763,7 +763,10 @@ def convert(self, value, param, ctx):\n @click.option(\"--host\", \"-h\", default=\"127.0.0.1\", help=\"The interface to bind to.\")\n @click.option(\"--port\", \"-p\", default=5000, help=\"The port to bind to.\")\n @click.option(\n-    \"--cert\", type=CertParamType(), help=\"Specify a certificate file to use HTTPS.\"\n+    \"--cert\",\n+    type=CertParamType(),\n+    help=\"Specify a certificate file to use HTTPS.\",\n+    is_eager=True,\n )\n @click.option(\n     \"--key\",\n", "test_patch": "diff --git a/tests/test_cli.py b/tests/test_cli.py\n--- a/tests/test_cli.py\n+++ b/tests/test_cli.py\n@@ -553,9 +553,14 @@ def test_run_cert_path():\n     with pytest.raises(click.BadParameter):\n         run_command.make_context(\"run\", [\"--key\", __file__])\n \n+    # cert specified first\n     ctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\n     assert ctx.params[\"cert\"] == (__file__, __file__)\n \n+    # key specified first\n+    ctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])\n+    assert ctx.params[\"cert\"] == (__file__, __file__)\n+\n \n def test_run_cert_adhoc(monkeypatch):\n     monkeypatch.setitem(sys.modules, \"cryptography\", None)\n", "problem_statement": "`flask run` rejects `--key foo.pem --cert foo.cert`\nWhen trying the development server, I find that `flask run --cert foo.cert --key foo.pem` works fine, but `flask run --key foo.pem --cert foo.cert` fails with:\r\n\r\n```\r\nError: Invalid value for '--key': \"--cert\" must also be specified.\r\n```\r\n\r\nIsn't this somewhat counterintuitive?\r\n\r\nIn flask/cli.py, [`_validate_key()`](https://github.com/pallets/flask/blob/3897a518014931a82c77a353e1e9c2248529b856/src/flask/cli.py#L711) function insists the certificate file should have been specified, and it feels too restrictive. But I'm not familiar with Click to contribute a pretty PR...\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9.10\r\n- Flask version: 2.0.3\n", "hints_text": "I am humbled to share my findings using `click`. Apparently, the order of arguments being passed to the `cli` seems to matter in `click`(not sure whether or not it is intentional).  I've found that the context manager only keeps track of the first option being passed. Take the following as an example:\r\n\r\n```python\r\nimport click\r\n\r\noptions = set()\r\n\r\ndef orders_params(ctx, param, value):\r\n    global options\r\n    print(ctx.params.items())\r\n    options.add((param, value))\r\n\r\n@click.command()\r\n@click.option(\"--foo\", required=True, multiple=True, callback=orders_params)\r\n@click.option(\"--bar\", required=True, multiple=True, callback=orders_params)\r\ndef run_command(*, foo, bar):\r\n    print(\"Parameters order:\")\r\n    for param, val in options:\r\n        print(\"   \" + param.name + str(val))\r\n\r\nif __name__ == \"__main__\":\r\n    run_command()\r\n```\r\n\r\nAfter running the above script, it generates different results depending on the ordering:\r\n\r\n```sh\r\n(.venv) \u279c  \u2717 python3 cli.py --foo foo --bar bar\r\ndict_items([])\r\ndict_items([('foo', None)])\r\nParameters order:\r\n   bar('bar',)\r\n   foo('foo',)\r\n\r\n(.venv) \u279c  \u2717 python3 cli.py --bar bar --foo foo\r\ndict_items([])\r\ndict_items([('bar', None)])\r\nParameters order:\r\n   foo('foo',)\r\n   bar('bar',)\r\n```\r\n\r\nAs you may notice, the output generated from the first command, the `ctx` object holds only the first option ` foo` after two callbacks being triggered. Similarly, the `ctx` object in the command contains only the first option `bar`.\r\n\r\nWith that noted, running `flask run --cert foo.cert --key foo.pem` and `flask run --key foo.pem --cert foo.cert` would result in different behavious.\r\n\r\nRunning the latter would result in `cert` being `None`:\r\n\r\nhttps://github.com/pallets/flask/blob/4843590c4a7f2225fd18bd10963139a6f29a2a59/src/flask/cli.py#L723\r\n\r\nAnd it will trigger the following case:\r\n\r\nhttps://github.com/pallets/flask/blob/4843590c4a7f2225fd18bd10963139a6f29a2a59/src/flask/cli.py#L738-L739\r\n\r\nIMHO, adding support for this edge case would require overriding the `parse_args` method of the `click.Command` and passing it in the decorator.\r\n\r\n```python\r\n@click.command(..., cls=OrderParams)\r\n                                   ^___ this argument\r\n```\r\n\r\nand OrderParams is some kind of class that inherits from `click.Command` to override the `parse_args` method.\r\n\r\n```python\r\nclass OrderParams(click.Command)\r\n  parse_args(self, ctx: click.core.Context, args: List[str]) -> List[str]:\r\n    # custom logic goes here\r\n```\r\n\r\nHopefully, the above info can help resolve the issue.\nWell, it's worth making the `_validate_cert` function. And for `--cert` option set `callback=_validate_cert`. Just a humble guess\nNo, implementing custom `Command.parse_args` is not the way to solve this.\n@davidism, how do you like my thoughts?\r\nNow I thought that this is not very good, because. the code is almost identical to `_validate_key`...\r\nI also wanted to add that I didn't mean to change the option type, I just want to add a new callback without changing the option type for `--cert`", "created_at": "2022-04-18T13:39:46Z"}
{"repo": "pallets/flask", "pull_number": 5063, "instance_id": "pallets__flask-5063", "issue_numbers": ["5004"], "base_commit": "182ce3dd15dfa3537391c3efaf9c3ff407d134d4", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -44,6 +44,8 @@ Unreleased\n     to set the domain, which modern browsers interpret as an exact match rather than\n     a subdomain match. Warnings about ``localhost`` and IP addresses are also removed.\n     :issue:`5051`\n+-   The ``routes`` command shows each rule's ``subdomain`` or ``host`` when domain\n+    matching is in use. :issue:`5004`\n \n \n Version 2.2.4\ndiff --git a/src/flask/cli.py b/src/flask/cli.py\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -9,7 +9,7 @@\n import traceback\n import typing as t\n from functools import update_wrapper\n-from operator import attrgetter\n+from operator import itemgetter\n \n import click\n from click.core import ParameterSource\n@@ -989,49 +989,62 @@ def shell_command() -> None:\n @click.option(\n     \"--sort\",\n     \"-s\",\n-    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n+    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\", \"match\")),\n     default=\"endpoint\",\n     help=(\n-        'Method to sort routes by. \"match\" is the order that Flask will match '\n-        \"routes when dispatching a request.\"\n+        \"Method to sort routes by. 'match' is the order that Flask will match routes\"\n+        \" when dispatching a request.\"\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n-\n     rules = list(current_app.url_map.iter_rules())\n+\n     if not rules:\n         click.echo(\"No routes were registered.\")\n         return\n \n-    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+    host_matching = current_app.url_map.host_matching\n+    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)\n+    rows = []\n \n-    if sort in (\"endpoint\", \"rule\"):\n-        rules = sorted(rules, key=attrgetter(sort))\n-    elif sort == \"methods\":\n-        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+    for rule in rules:\n+        row = [\n+            rule.endpoint,\n+            \", \".join(sorted((rule.methods or set()) - ignored_methods)),\n+        ]\n \n-    rule_methods = [\n-        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n-        for rule in rules\n-    ]\n+        if has_domain:\n+            row.append((rule.host if host_matching else rule.subdomain) or \"\")\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n-    widths = (\n-        max(len(rule.endpoint) for rule in rules),\n-        max(len(methods) for methods in rule_methods),\n-        max(len(rule.rule) for rule in rules),\n-    )\n-    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+        row.append(rule.rule)\n+        rows.append(row)\n+\n+    headers = [\"Endpoint\", \"Methods\"]\n+    sorts = [\"endpoint\", \"methods\"]\n+\n+    if has_domain:\n+        headers.append(\"Host\" if host_matching else \"Subdomain\")\n+        sorts.append(\"domain\")\n+\n+    headers.append(\"Rule\")\n+    sorts.append(\"rule\")\n+\n+    try:\n+        rows.sort(key=itemgetter(sorts.index(sort)))\n+    except ValueError:\n+        pass\n \n-    click.echo(row.format(*headers).strip())\n-    click.echo(row.format(*(\"-\" * width for width in widths)))\n+    rows.insert(0, headers)\n+    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]\n+    rows.insert(1, [\"-\" * w for w in widths])\n+    template = \"  \".join(f\"{{{i}:<{w}}}\" for i, w in enumerate(widths))\n \n-    for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+    for row in rows:\n+        click.echo(template.format(*row))\n \n \n cli = FlaskGroup(\n", "test_patch": "diff --git a/tests/test_cli.py b/tests/test_cli.py\n--- a/tests/test_cli.py\n+++ b/tests/test_cli.py\n@@ -433,16 +433,12 @@ class TestRoutes:\n     @pytest.fixture\n     def app(self):\n         app = Flask(__name__)\n-        app.testing = True\n-\n-        @app.route(\"/get_post/<int:x>/<int:y>\", methods=[\"GET\", \"POST\"])\n-        def yyy_get_post(x, y):\n-            pass\n-\n-        @app.route(\"/zzz_post\", methods=[\"POST\"])\n-        def aaa_post():\n-            pass\n-\n+        app.add_url_rule(\n+            \"/get_post/<int:x>/<int:y>\",\n+            methods=[\"GET\", \"POST\"],\n+            endpoint=\"yyy_get_post\",\n+        )\n+        app.add_url_rule(\"/zzz_post\", methods=[\"POST\"], endpoint=\"aaa_post\")\n         return app\n \n     @pytest.fixture\n@@ -450,17 +446,6 @@ def invoke(self, app, runner):\n         cli = FlaskGroup(create_app=lambda: app)\n         return partial(runner.invoke, cli)\n \n-    @pytest.fixture\n-    def invoke_no_routes(self, runner):\n-        def create_app():\n-            app = Flask(__name__, static_folder=None)\n-            app.testing = True\n-\n-            return app\n-\n-        cli = FlaskGroup(create_app=create_app)\n-        return partial(runner.invoke, cli)\n-\n     def expect_order(self, order, output):\n         # skip the header and match the start of each row\n         for expect, line in zip(order, output.splitlines()[2:]):\n@@ -493,11 +478,31 @@ def test_all_methods(self, invoke):\n         output = invoke([\"routes\", \"--all-methods\"]).output\n         assert \"GET, HEAD, OPTIONS, POST\" in output\n \n-    def test_no_routes(self, invoke_no_routes):\n-        result = invoke_no_routes([\"routes\"])\n+    def test_no_routes(self, runner):\n+        app = Flask(__name__, static_folder=None)\n+        cli = FlaskGroup(create_app=lambda: app)\n+        result = runner.invoke(cli, [\"routes\"])\n         assert result.exit_code == 0\n         assert \"No routes were registered.\" in result.output\n \n+    def test_subdomain(self, runner):\n+        app = Flask(__name__, static_folder=None)\n+        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n+        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n+        cli = FlaskGroup(create_app=lambda: app)\n+        result = runner.invoke(cli, [\"routes\"])\n+        assert result.exit_code == 0\n+        assert \"Subdomain\" in result.output\n+\n+    def test_host(self, runner):\n+        app = Flask(__name__, static_folder=None, host_matching=True)\n+        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n+        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n+        cli = FlaskGroup(create_app=lambda: app)\n+        result = runner.invoke(cli, [\"routes\"])\n+        assert result.exit_code == 0\n+        assert \"Host\" in result.output\n+\n \n def dotenv_not_available():\n     try:\n", "problem_statement": "Flask routes to return domain/sub-domains information\nCurrently when checking **flask routes** it provides all routes but **it is no way to see which routes are assigned to which subdomain**.\r\n\r\n**Default server name:**\r\nSERVER_NAME: 'test.local'\r\n\r\n**Domains (sub-domains):**\r\ntest.test.local\r\nadmin.test.local\r\ntest.local\r\n\r\n**Adding blueprints:**\r\napp.register_blueprint(admin_blueprint,url_prefix='',subdomain='admin')\r\napp.register_blueprint(test_subdomain_blueprint,url_prefix='',subdomain='test')\r\n\r\n\r\n```\r\n$ flask routes\r\n * Tip: There are .env or .flaskenv files present. Do \"pip install python-dotenv\" to use them.\r\nEndpoint                                                 Methods    Rule\r\n-------------------------------------------------------  ---------  ------------------------------------------------\r\nadmin_blueprint.home                                      GET        /home\r\ntest_subdomain_blueprint.home                             GET        /home\r\nstatic                                                    GET        /static/<path:filename>\r\n...\r\n```\r\n\r\n\r\n**Feature request**\r\nIt will be good to see something like below (that will make more clear which route for which subdomain, because now need to go and check configuration).\r\n**If it is not possible to fix routes**, can you add or tell which method(s) should be used to get below information from flask? \r\n\r\n```\r\n$ flask routes\r\n * Tip: There are .env or .flaskenv files present. Do \"pip install python-dotenv\" to use them.\r\nDomain                Endpoint                                             Methods    Rule\r\n-----------------   ----------------------------------------------------  ----------  ------------------------------------------------\r\nadmin.test.local     admin_blueprint.home                                  GET        /home\r\ntest.test.local      test_subdomain_blueprint.home                         GET        /home\r\ntest.local           static                                                GET        /static/<path:filename>\r\n...\r\n```\r\n\n", "hints_text": "", "created_at": "2023-04-14T16:36:54Z"}
{"repo": "pallets/flask", "pull_number": 4045, "instance_id": "pallets__flask-4045", "issue_numbers": ["4041"], "base_commit": "d8c37f43724cd9fb0870f77877b7c4c7e38a19e0", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -15,6 +15,9 @@ Unreleased\n -   Fix some types that weren't available in Python 3.6.0. :issue:`4040`\n -   Improve typing for ``send_file``, ``send_from_directory``, and\n     ``get_send_file_max_age``. :issue:`4044`, :pr:`4026`\n+-   Show an error when a blueprint name contains a dot. The ``.`` has\n+    special meaning, it is used to separate (nested) blueprint names and\n+    the endpoint name. :issue:`4041`\n \n \n Version 2.0.0\ndiff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -188,6 +188,10 @@ def __init__(\n             template_folder=template_folder,\n             root_path=root_path,\n         )\n+\n+        if \".\" in name:\n+            raise ValueError(\"'name' may not contain a dot '.' character.\")\n+\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n@@ -360,12 +364,12 @@ def add_url_rule(\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the blueprint.\n         \"\"\"\n-        if endpoint:\n-            assert \".\" not in endpoint, \"Blueprint endpoints should not contain dots\"\n-        if view_func and hasattr(view_func, \"__name__\"):\n-            assert (\n-                \".\" not in view_func.__name__\n-            ), \"Blueprint view function name should not contain dots\"\n+        if endpoint and \".\" in endpoint:\n+            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n+\n+        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n+            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n+\n         self.record(lambda s: s.add_url_rule(rule, endpoint, view_func, **options))\n \n     def app_template_filter(self, name: t.Optional[str] = None) -> t.Callable:\n", "test_patch": "diff --git a/tests/test_basic.py b/tests/test_basic.py\n--- a/tests/test_basic.py\n+++ b/tests/test_basic.py\n@@ -1631,7 +1631,7 @@ def something_else():\n \n \n def test_inject_blueprint_url_defaults(app):\n-    bp = flask.Blueprint(\"foo.bar.baz\", __name__, template_folder=\"template\")\n+    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n \n     @bp.url_defaults\n     def bp_defaults(endpoint, values):\n@@ -1644,12 +1644,12 @@ def view(page):\n     app.register_blueprint(bp)\n \n     values = dict()\n-    app.inject_url_defaults(\"foo.bar.baz.view\", values)\n+    app.inject_url_defaults(\"foo.view\", values)\n     expected = dict(page=\"login\")\n     assert values == expected\n \n     with app.test_request_context(\"/somepage\"):\n-        url = flask.url_for(\"foo.bar.baz.view\")\n+        url = flask.url_for(\"foo.view\")\n     expected = \"/login\"\n     assert url == expected\n \ndiff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -1,5 +1,3 @@\n-import functools\n-\n import pytest\n from jinja2 import TemplateNotFound\n from werkzeug.http import parse_cache_control_header\n@@ -253,28 +251,9 @@ def test_templates_list(test_apps):\n     assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n \n \n-def test_dotted_names(app, client):\n-    frontend = flask.Blueprint(\"myapp.frontend\", __name__)\n-    backend = flask.Blueprint(\"myapp.backend\", __name__)\n-\n-    @frontend.route(\"/fe\")\n-    def frontend_index():\n-        return flask.url_for(\"myapp.backend.backend_index\")\n-\n-    @frontend.route(\"/fe2\")\n-    def frontend_page2():\n-        return flask.url_for(\".frontend_index\")\n-\n-    @backend.route(\"/be\")\n-    def backend_index():\n-        return flask.url_for(\"myapp.frontend.frontend_index\")\n-\n-    app.register_blueprint(frontend)\n-    app.register_blueprint(backend)\n-\n-    assert client.get(\"/fe\").data.strip() == b\"/be\"\n-    assert client.get(\"/fe2\").data.strip() == b\"/fe\"\n-    assert client.get(\"/be\").data.strip() == b\"/fe\"\n+def test_dotted_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"app.ui\", __name__)\n \n \n def test_dotted_names_from_app(app, client):\n@@ -343,62 +322,19 @@ def index():\n def test_route_decorator_custom_endpoint_with_dots(app, client):\n     bp = flask.Blueprint(\"bp\", __name__)\n \n-    @bp.route(\"/foo\")\n-    def foo():\n-        return flask.request.endpoint\n-\n-    try:\n-\n-        @bp.route(\"/bar\", endpoint=\"bar.bar\")\n-        def foo_bar():\n-            return flask.request.endpoint\n-\n-    except AssertionError:\n-        pass\n-    else:\n-        raise AssertionError(\"expected AssertionError not raised\")\n-\n-    try:\n-\n-        @bp.route(\"/bar/123\", endpoint=\"bar.123\")\n-        def foo_bar_foo():\n-            return flask.request.endpoint\n-\n-    except AssertionError:\n-        pass\n-    else:\n-        raise AssertionError(\"expected AssertionError not raised\")\n-\n-    def foo_foo_foo():\n-        pass\n-\n-    pytest.raises(\n-        AssertionError,\n-        lambda: bp.add_url_rule(\"/bar/123\", endpoint=\"bar.123\", view_func=foo_foo_foo),\n-    )\n-\n-    pytest.raises(\n-        AssertionError, bp.route(\"/bar/123\", endpoint=\"bar.123\"), lambda: None\n-    )\n-\n-    foo_foo_foo.__name__ = \"bar.123\"\n+    with pytest.raises(ValueError):\n+        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n \n-    pytest.raises(\n-        AssertionError, lambda: bp.add_url_rule(\"/bar/123\", view_func=foo_foo_foo)\n-    )\n+    with pytest.raises(ValueError):\n+        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n \n-    bp.add_url_rule(\n-        \"/bar/456\", endpoint=\"foofoofoo\", view_func=functools.partial(foo_foo_foo)\n-    )\n+    def view():\n+        return \"\"\n \n-    app.register_blueprint(bp, url_prefix=\"/py\")\n+    view.__name__ = \"a.b\"\n \n-    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n-    # The rule's didn't actually made it through\n-    rv = client.get(\"/py/bar\")\n-    assert rv.status_code == 404\n-    rv = client.get(\"/py/bar/123\")\n-    assert rv.status_code == 404\n+    with pytest.raises(ValueError):\n+        bp.add_url_rule(\"/\", view_func=view)\n \n \n def test_endpoint_decorator(app, client):\n", "problem_statement": "Raise error when blueprint name contains a dot\nThis is required since every dot is now significant since blueprints can be nested. An error was already added for endpoint names in 1.0, but should have been added for this as well.\n", "hints_text": "", "created_at": "2021-05-13T21:32:41Z"}
{"repo": "pallets/flask", "pull_number": 4642, "instance_id": "pallets__flask-4642", "issue_numbers": ["3263"], "base_commit": "97298e06fe19298c3ff9d2e0ed9ba70bb3fda2c8", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -25,6 +25,9 @@ Unreleased\n -   Added the ``View.init_every_request`` class attribute. If a view\n     subclass sets this to ``False``, the view will not create a new\n     instance on every request. :issue:`2520`.\n+-   A ``flask.cli.FlaskGroup`` Click group can be nested as a\n+    sub-command in a custom CLI. :issue:`3263`\n+\n \n Version 2.1.3\n -------------\ndiff --git a/src/flask/app.py b/src/flask/app.py\n--- a/src/flask/app.py\n+++ b/src/flask/app.py\n@@ -10,6 +10,7 @@\n from threading import Lock\n from types import TracebackType\n \n+import click\n from werkzeug.datastructures import Headers\n from werkzeug.datastructures import ImmutableDict\n from werkzeug.exceptions import Aborter\n@@ -23,6 +24,7 @@\n from werkzeug.routing import RequestRedirect\n from werkzeug.routing import RoutingException\n from werkzeug.routing import Rule\n+from werkzeug.serving import is_running_from_reloader\n from werkzeug.urls import url_quote\n from werkzeug.utils import redirect as _wz_redirect\n from werkzeug.wrappers import Response as BaseResponse\n@@ -908,12 +910,18 @@ def run(\n             The default port is now picked from the ``SERVER_NAME``\n             variable.\n         \"\"\"\n-        # Change this into a no-op if the server is invoked from the\n-        # command line. Have a look at cli.py for more information.\n+        # Ignore this call so that it doesn't start another server if\n+        # the 'flask run' command is used.\n         if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n-            from .debughelpers import explain_ignored_app_run\n+            if not is_running_from_reloader():\n+                click.secho(\n+                    \" * Ignoring a call to 'app.run()', the server is\"\n+                    \" already being run with the 'flask run' command.\\n\"\n+                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n+                    ' \"__main__\"\\' guard.',\n+                    fg=\"red\",\n+                )\n \n-            explain_ignored_app_run()\n             return\n \n         if get_load_dotenv(load_dotenv):\ndiff --git a/src/flask/cli.py b/src/flask/cli.py\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -5,12 +5,14 @@\n import re\n import sys\n import traceback\n+import typing as t\n from functools import update_wrapper\n from operator import attrgetter\n from threading import Lock\n from threading import Thread\n \n import click\n+from werkzeug.serving import is_running_from_reloader\n from werkzeug.utils import import_string\n \n from .globals import current_app\n@@ -273,7 +275,7 @@ def __init__(self, loader, use_eager_loading=None):\n         self._bg_loading_exc = None\n \n         if use_eager_loading is None:\n-            use_eager_loading = os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\"\n+            use_eager_loading = not is_running_from_reloader()\n \n         if use_eager_loading:\n             self._load_unlocked()\n@@ -477,7 +479,13 @@ def __init__(\n         if add_version_option:\n             params.append(version_option)\n \n-        AppGroup.__init__(self, params=params, **extra)\n+        if \"context_settings\" not in extra:\n+            extra[\"context_settings\"] = {}\n+\n+        extra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"FLASK\")\n+\n+        super().__init__(params=params, **extra)\n+\n         self.create_app = create_app\n         self.load_dotenv = load_dotenv\n         self.set_debug_flag = set_debug_flag\n@@ -545,26 +553,22 @@ def list_commands(self, ctx):\n \n         return sorted(rv)\n \n-    def main(self, *args, **kwargs):\n-        # Set a global flag that indicates that we were invoked from the\n-        # command line interface. This is detected by Flask.run to make the\n-        # call into a no-op. This is necessary to avoid ugly errors when the\n-        # script that is loaded here also attempts to start a server.\n-        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n-\n+    def make_context(\n+        self,\n+        info_name: t.Optional[str],\n+        args: t.List[str],\n+        parent: t.Optional[click.Context] = None,\n+        **extra: t.Any,\n+    ) -> click.Context:\n         if get_load_dotenv(self.load_dotenv):\n             load_dotenv()\n \n-        obj = kwargs.get(\"obj\")\n-\n-        if obj is None:\n-            obj = ScriptInfo(\n+        if \"obj\" not in extra and \"obj\" not in self.context_settings:\n+            extra[\"obj\"] = ScriptInfo(\n                 create_app=self.create_app, set_debug_flag=self.set_debug_flag\n             )\n \n-        kwargs[\"obj\"] = obj\n-        kwargs.setdefault(\"auto_envvar_prefix\", \"FLASK\")\n-        return super().main(*args, **kwargs)\n+        return super().make_context(info_name, args, parent=parent, **extra)\n \n \n def _path_is_ancestor(path, other):\n@@ -637,7 +641,7 @@ def show_server_banner(env, debug, app_import_path, eager_loading):\n     \"\"\"Show extra startup messages the first time the server is run,\n     ignoring the reloader.\n     \"\"\"\n-    if os.environ.get(\"WERKZEUG_RUN_MAIN\") == \"true\":\n+    if is_running_from_reloader():\n         return\n \n     if app_import_path is not None:\n@@ -653,10 +657,10 @@ def show_server_banner(env, debug, app_import_path, eager_loading):\n     if env == \"production\":\n         click.secho(\n             \"   WARNING: This is a development server. Do not use it in\"\n-            \" a production deployment.\",\n+            \" a production deployment.\\n   Use a production WSGI server\"\n+            \" instead.\",\n             fg=\"red\",\n         )\n-        click.secho(\"   Use a production WSGI server instead.\", dim=True)\n \n     if debug is not None:\n         click.echo(f\" * Debug mode: {'on' if debug else 'off'}\")\n@@ -963,6 +967,7 @@ def routes_command(sort: str, all_methods: bool) -> None:\n \n \n cli = FlaskGroup(\n+    name=\"flask\",\n     help=\"\"\"\\\n A general utility script for Flask applications.\n \n@@ -978,7 +983,7 @@ def routes_command(sort: str, all_methods: bool) -> None:\n \"\"\".format(\n         cmd=\"export\" if os.name == \"posix\" else \"set\",\n         prefix=\"$ \" if os.name == \"posix\" else \"> \",\n-    )\n+    ),\n )\n \n \ndiff --git a/src/flask/debughelpers.py b/src/flask/debughelpers.py\n--- a/src/flask/debughelpers.py\n+++ b/src/flask/debughelpers.py\n@@ -1,6 +1,4 @@\n-import os\n import typing as t\n-from warnings import warn\n \n from .app import Flask\n from .blueprints import Blueprint\n@@ -159,16 +157,3 @@ def explain_template_loading_attempts(app: Flask, template, attempts) -> None:\n         info.append(\"  See https://flask.palletsprojects.com/blueprints/#templates\")\n \n     app.logger.info(\"\\n\".join(info))\n-\n-\n-def explain_ignored_app_run() -> None:\n-    if os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\":\n-        warn(\n-            Warning(\n-                \"Silently ignoring app.run() because the application is\"\n-                \" run from the flask command line executable. Consider\"\n-                ' putting app.run() behind an if __name__ == \"__main__\"'\n-                \" guard to silence this warning.\"\n-            ),\n-            stacklevel=3,\n-        )\n", "test_patch": "diff --git a/tests/test_cli.py b/tests/test_cli.py\n--- a/tests/test_cli.py\n+++ b/tests/test_cli.py\n@@ -388,6 +388,19 @@ def test():\n     assert result.output == f\"{not set_debug_flag}\\n\"\n \n \n+def test_flaskgroup_nested(app, runner):\n+    cli = click.Group(\"cli\")\n+    flask_group = FlaskGroup(name=\"flask\", create_app=lambda: app)\n+    cli.add_command(flask_group)\n+\n+    @flask_group.command()\n+    def show():\n+        click.echo(current_app.name)\n+\n+    result = runner.invoke(cli, [\"flask\", \"show\"])\n+    assert result.output == \"flask_test\\n\"\n+\n+\n def test_no_command_echo_loading_error():\n     from flask.cli import cli\n \n", "problem_statement": "FlaskGroup does not work when nested in a click.group\n### Expected Behavior\r\nWhen using Flask CLI, I came to the case that we have a group of commands for a big program that uses `click`.\r\n```python\r\n# main group\r\n@click.group()\r\n@click.pass_context\r\ndef my_big_cli_group(ctx):\r\n    pass\r\n\r\n# sub group\r\n@my_big_cli_group.group()\r\n@click.pass_context\r\ndef my_nested_group(ctx):\r\n    pass\r\n\r\n# command for sub group\r\n@my_nested_group.command()\r\n@click.pass_context\r\n@click.option('-s', '--start', is_flag=True)\r\ndef my_command(ctx, start):\r\n    click.echo(start)\r\n```\r\n\r\nThe issue comes when nesting my flask app into the bigger group using `cls=FlaskGroup` and passing my `create_app` factory function.\r\n\r\n```python\r\n# flask app sub group\r\n@my_big_cli_group.group(cls=FlaskGroup, create_app=create_app)\r\n@click.pass_context\r\ndef my_flask_app(ctx):\r\n    pass\r\n```\r\n\r\nAfter running my `setup.py` pointing my entry point to `'my_big_cli = path.to:my_big_cli_group'`, I should expect the app to start once I do:\r\n```bash\r\n$ my_big_cli my_flask_app run\r\n```\r\n\r\n### Actual Behavior\r\nInstead, I get a `flask.cli.NoAppException`. It seems that `create_app` does not get passed on to `Group.group` instances on `click`.\r\n\r\n```pytb\r\nTraceback (most recent call last):\r\n File \u201c/Users/the_user/Desktop/venv/lib/python3.7/site-packages/flask/cli.py\u201d, line 540, in list_commands\r\n   rv.update(info.load_app().cli.list_commands(ctx))\r\n File \u201c/Users/the_user/Desktop/venv/lib/python3.7/site-packages/flask/cli.py\u201d, line 393, in load_app\r\n   \u2018Could not locate a Flask application. You did not provide \u2019\r\nflask.cli.NoAppException: Could not locate a Flask application. You did not provide the \u201cFLASK_APP\u201d environment variable, and a \u201cwsgi.py\u201d or \u201capp.py\u201d module was not found in the current directory.\r\n```\r\n\r\n### Work around\r\nIf I don't nest the flask app into a group but rather make it a new `click.group`, then after changing my `setup.py` to point to this new entry point as well, everything works as expected.\r\n\r\n```python\r\n# flask app group\r\n@click.group(cls=FlaskGroup, create_app=create_app)\r\n@click.pass_context\r\ndef my_flask_app(ctx):\r\n    pass\r\n```\r\nThen\r\n```bash\r\n$ my_flask_app run\r\n```\r\nworks perfectly fine\r\n\r\n\r\n### Environment\r\n\r\n* Python version: 3.7.3\r\n* Flask version: 1.0.3\r\n* Werkzeug version: 0.15.4\n", "hints_text": "There are some bootstrap code in `FlaskGroup.main()`, so I think it is not allowed to nest it in another group, because the function is never called.\nAh, interesting. Could there be any workaround for this to be allowed? I guess at the end `Flask` should be fully compatible with all `click` functionalities (group `nesting` being one of the main ones).\nPassing create_app as a parameter doesn't work in this case, but you can still use FLASK_APP environment variable to do the trick. Note that some functionalities are still missing, such as dotenv loading.\nI also came across this issue, I dug into the source and was able to make a minor change which *seems* to do the trick. I have yet to test it more thoroughly however, perhaps someone here can figure out if this affects something else.\r\n\r\nQuite simply I re-write FlaskGroup and replace `main` with `make_context` (naturally, the call and the `super()`) here https://github.com/pallets/flask/blob/master/src/flask/cli.py#L578-L597\r\n\r\nThis is because in click, one of the first things that are done in `main` is to call `make_context` with `kwargs` (https://github.com/pallets/click/blob/master/src/click/core.py#L809)\r\n\r\nWhich ends up here: https://github.com/pallets/click/blob/35f73b8c2c314e56968de8bc483da9a84ac5c53e/src/click/core.py#L712 \r\nIt looks to me like injecting kwargs into this function instead of main should work just as well. In my simple tests, this seems to enable me to run the flask apps using the new FlaskGroup in sub groups.\r\n\r\nAfter additional testing I may consider writing a PR if no one beats me to it.\n@u8sand Thanks a lot for your research!\r\n\r\nFor anyone else wondering how to avoid this issue, this is the code I used (simplified a bit):\r\n\r\n```python3\r\nclass CustomGroup(FlaskGroup):\r\n    def make_context(self, *args, **extra):\r\n        obj = extra.get(\"obj\")\r\n        if obj is None:\r\n            obj = ScriptInfo(create_app=self.create_app, set_debug_flag=self.set_debug_flag)\r\n        extra[\"obj\"] = obj\r\n\r\n        return super().make_context(*args, **extra)\r\n\r\n@click.group(cls=CustomGroup)\r\n...\r\n````", "created_at": "2022-06-15T21:14:32Z"}
{"repo": "pallets/flask", "pull_number": 4935, "instance_id": "pallets__flask-4935", "issue_numbers": ["4834"], "base_commit": "fa1ee7066807c21256e90089731c548b313394d2", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -3,6 +3,8 @@ Version 2.3.0\n \n Unreleased\n \n+-   Ensure subdomains are applied with nested blueprints. :issue:`4834`\n+\n \n Version 2.2.3\n -------------\ndiff --git a/docs/blueprints.rst b/docs/blueprints.rst\n--- a/docs/blueprints.rst\n+++ b/docs/blueprints.rst\n@@ -140,6 +140,19 @@ name, and child URLs will be prefixed with the parent's URL prefix.\n     url_for('parent.child.create')\n     /parent/child/create\n \n+In addition a child blueprint's will gain their parent's subdomain,\n+with their subdomain as prefix if present i.e.\n+\n+.. code-block:: python\n+\n+    parent = Blueprint('parent', __name__, subdomain='parent')\n+    child = Blueprint('child', __name__, subdomain='child')\n+    parent.register_blueprint(child)\n+    app.register_blueprint(parent)\n+\n+    url_for('parent.child.create', _external=True)\n+    \"child.parent.domain.tld\"\n+\n Blueprint-specific before request functions, etc. registered with the\n parent will trigger for the child. If a child does not have an error\n handler that can handle a given exception, the parent's will be tried.\ndiff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -358,6 +358,9 @@ def register(self, app: \"Flask\", options: dict) -> None:\n         :param options: Keyword arguments forwarded from\n             :meth:`~Flask.register_blueprint`.\n \n+        .. versionchanged:: 2.3\n+            Nested blueprints now correctly apply subdomains.\n+\n         .. versionchanged:: 2.0.1\n             Nested blueprints are registered with their dotted name.\n             This allows different blueprints with the same name to be\n@@ -453,6 +456,17 @@ def extend(bp_dict, parent_dict):\n         for blueprint, bp_options in self._blueprints:\n             bp_options = bp_options.copy()\n             bp_url_prefix = bp_options.get(\"url_prefix\")\n+            bp_subdomain = bp_options.get(\"subdomain\")\n+\n+            if bp_subdomain is None:\n+                bp_subdomain = blueprint.subdomain\n+\n+            if state.subdomain is not None and bp_subdomain is not None:\n+                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\n+            elif bp_subdomain is not None:\n+                bp_options[\"subdomain\"] = bp_subdomain\n+            elif state.subdomain is not None:\n+                bp_options[\"subdomain\"] = state.subdomain\n \n             if bp_url_prefix is None:\n                 bp_url_prefix = blueprint.url_prefix\n", "test_patch": "diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -950,6 +950,55 @@ def index():\n     assert response.status_code == 200\n \n \n+def test_nesting_subdomains(app, client) -> None:\n+    subdomain = \"api\"\n+    parent = flask.Blueprint(\"parent\", __name__)\n+    child = flask.Blueprint(\"child\", __name__)\n+\n+    @child.route(\"/child/\")\n+    def index():\n+        return \"child\"\n+\n+    parent.register_blueprint(child)\n+    app.register_blueprint(parent, subdomain=subdomain)\n+\n+    client.allow_subdomain_redirects = True\n+\n+    domain_name = \"domain.tld\"\n+    app.config[\"SERVER_NAME\"] = domain_name\n+    response = client.get(\"/child/\", base_url=\"http://api.\" + domain_name)\n+\n+    assert response.status_code == 200\n+\n+\n+def test_child_and_parent_subdomain(app, client) -> None:\n+    child_subdomain = \"api\"\n+    parent_subdomain = \"parent\"\n+    parent = flask.Blueprint(\"parent\", __name__)\n+    child = flask.Blueprint(\"child\", __name__, subdomain=child_subdomain)\n+\n+    @child.route(\"/\")\n+    def index():\n+        return \"child\"\n+\n+    parent.register_blueprint(child)\n+    app.register_blueprint(parent, subdomain=parent_subdomain)\n+\n+    client.allow_subdomain_redirects = True\n+\n+    domain_name = \"domain.tld\"\n+    app.config[\"SERVER_NAME\"] = domain_name\n+    response = client.get(\n+        \"/\", base_url=f\"http://{child_subdomain}.{parent_subdomain}.{domain_name}\"\n+    )\n+\n+    assert response.status_code == 200\n+\n+    response = client.get(\"/\", base_url=f\"http://{parent_subdomain}.{domain_name}\")\n+\n+    assert response.status_code == 404\n+\n+\n def test_unique_blueprint_names(app, client) -> None:\n     bp = flask.Blueprint(\"bp\", __name__)\n     bp2 = flask.Blueprint(\"bp\", __name__)\n", "problem_statement": "Nested blueprints are not respected when mounted on subdomains\nHello, and thanks for all your work \ud83d\ude4f\ud83c\udffb \r\n\r\nNested blueprints [as described in the docs](https://flask.palletsprojects.com/en/2.2.x/blueprints/#nesting-blueprints) work perfectly fine when using `url_prefix`. However, when mounting the parent blueprint using a subdomain, the child routes are not accessible.\r\n\r\n```python\r\nfrom flask import Flask\r\nfrom flask import Blueprint\r\n\r\napp = Flask(__name__)\r\napp.config[\"SERVER_NAME\"] = \"localhost:5000\"\r\nparent = Blueprint(\"parent\", __name__)\r\nchild = Blueprint(\"child\", __name__)\r\n\r\n@app.route('/')\r\ndef index():\r\n    return \"index\"\r\n\r\n@parent.route('/')\r\ndef parent_index():\r\n    return \"parent\"\r\n\r\n@child.route('/child/')\r\ndef child_index():\r\n    return \"child\"\r\n\r\nparent.register_blueprint(child)\r\napp.register_blueprint(parent, subdomain=\"api\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n```\r\n\r\nThe index route works as expected:\r\n\r\n```\r\n\u276f http http://localhost:5000/\r\nHTTP/1.1 200 OK\r\nConnection: close\r\nContent-Length: 5\r\nContent-Type: text/html; charset=utf-8\r\nDate: Tue, 04 Oct 2022 10:44:10 GMT\r\nServer: Werkzeug/2.2.2 Python/3.10.4\r\n\r\nindex\r\n```\r\n\r\nSo does the parent route in the subdomain:\r\n\r\n```\r\n\u276f http http://api.localhost:5000/\r\nHTTP/1.1 200 OK\r\nConnection: close\r\nContent-Length: 6\r\nContent-Type: text/html; charset=utf-8\r\nDate: Tue, 04 Oct 2022 10:44:06 GMT\r\nServer: Werkzeug/2.2.2 Python/3.10.4\r\n\r\nparent\r\n```\r\n\r\nBut the child responds with a 404:\r\n\r\n```\r\n\u276f http http://api.localhost:5000/child/\r\nHTTP/1.1 404 NOT FOUND\r\nConnection: close\r\nContent-Length: 207\r\nContent-Type: text/html; charset=utf-8\r\nDate: Tue, 04 Oct 2022 10:45:42 GMT\r\nServer: Werkzeug/2.2.2 Python/3.10.4\r\n\r\n<!doctype html>\r\n<html lang=en>\r\n<title>404 Not Found</title>\r\n<h1>Not Found</h1>\r\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\r\n```\r\n\r\nIf we change the `subdomain=\"api\"` for `url_prefix=\"/api\"` when registering the blueprint however everything works as expected:\r\n\r\n```\r\n\u276f http http://localhost:5000/api/\r\nHTTP/1.1 200 OK\r\nConnection: close\r\nContent-Length: 6\r\nContent-Type: text/html; charset=utf-8\r\nDate: Tue, 04 Oct 2022 10:46:53 GMT\r\nServer: Werkzeug/2.2.2 Python/3.10.4\r\n\r\nparent\r\n\r\n\u276f http http://localhost:5000/api/child/\r\nHTTP/1.1 200 OK\r\nConnection: close\r\nContent-Length: 5\r\nContent-Type: text/html; charset=utf-8\r\nDate: Tue, 04 Oct 2022 10:46:59 GMT\r\nServer: Werkzeug/2.2.2 Python/3.10.4\r\n\r\nchild\r\n```\r\n\r\nThis was surprising to me as I expected the same nesting to apply regardless of whether the parent is mounted using a subdomain or a URL prefix. Am I missing something?\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10\r\n- Flask version: 2.2.2\r\n\n", "hints_text": "It looks like if you request `http://localhost:5000/child/`, you'll get 200 OK.\r\n\r\nIt means that when registering child blueprints, they don't respect the subdomain set by the parent.\r\n\r\nI submitted a PR at #4855.", "created_at": "2023-01-04T16:50:46Z"}
{"repo": "pallets/flask", "pull_number": 4160, "instance_id": "pallets__flask-4160", "issue_numbers": ["4157"], "base_commit": "06cf349bb8b69d9946c3a6a64d32eb552cc7c28b", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -15,6 +15,8 @@ Unreleased\n -   Fix registering a blueprint twice with differing names. :issue:`4124`\n -   Fix the type of ``static_folder`` to accept ``pathlib.Path``.\n     :issue:`4150`\n+-   ``jsonify`` handles ``decimal.Decimal`` by encoding to ``str``.\n+    :issue:`4157`\n \n \n Version 2.0.1\ndiff --git a/src/flask/json/__init__.py b/src/flask/json/__init__.py\n--- a/src/flask/json/__init__.py\n+++ b/src/flask/json/__init__.py\n@@ -1,3 +1,4 @@\n+import decimal\n import io\n import json as _json\n import typing as t\n@@ -47,7 +48,7 @@ def default(self, o: t.Any) -> t.Any:\n         \"\"\"\n         if isinstance(o, date):\n             return http_date(o)\n-        if isinstance(o, uuid.UUID):\n+        if isinstance(o, (decimal.Decimal, uuid.UUID)):\n             return str(o)\n         if dataclasses and dataclasses.is_dataclass(o):\n             return dataclasses.asdict(o)\n@@ -117,6 +118,9 @@ def dumps(obj: t.Any, app: t.Optional[\"Flask\"] = None, **kwargs: t.Any) -> str:\n         or defaults.\n     :param kwargs: Extra arguments passed to :func:`json.dumps`.\n \n+    .. versionchanged:: 2.0.2\n+        :class:`decimal.Decimal` is supported by converting to a string.\n+\n     .. versionchanged:: 2.0\n         ``encoding`` is deprecated and will be removed in Flask 2.1.\n \n@@ -324,6 +328,9 @@ def get_current_user():\n     debug mode or if :data:`JSONIFY_PRETTYPRINT_REGULAR` is ``True``,\n     the output will be formatted to be easier to read.\n \n+    .. versionchanged:: 2.0.2\n+        :class:`decimal.Decimal` is supported by converting to a string.\n+\n     .. versionchanged:: 0.11\n         Added support for serializing top-level arrays. This introduces\n         a security risk in ancient browsers. See :ref:`security-json`.\n", "test_patch": "diff --git a/tests/test_json.py b/tests/test_json.py\n--- a/tests/test_json.py\n+++ b/tests/test_json.py\n@@ -1,4 +1,5 @@\n import datetime\n+import decimal\n import io\n import uuid\n \n@@ -187,6 +188,11 @@ def test_jsonify_uuid_types(app, client):\n     assert rv_uuid == test_uuid\n \n \n+def test_json_decimal():\n+    rv = flask.json.dumps(decimal.Decimal(\"0.003\"))\n+    assert rv == '\"0.003\"'\n+\n+\n def test_json_attr(app, client):\n     @app.route(\"/add\", methods=[\"POST\"])\n     def add():\n", "problem_statement": "handle Decimal in json encoder\nThe `simplejson` removal (#3555) decreased the flask encoding capabilities as the built-in `json` doesn't cover cases like `Decimal` types. The solution seems to be: overwrite the flask app encoder with `JSONEnconder` from `simplejson`, but this incorporates a problem for users that relies on both `Decimal` and `datetimes` as `simplejon` doesn't handle `datetimes`, while flask encoder does. The solution I found is to build a custom encoder that tests if the value is `Decimal` and gives it to `simplejson`, otherwise, handles it with the default flask app encoder. My suggestion is to incorporate a simple test in the flask encoder to add `Decimal` coverage, that would remove any residual dependency on `simplejson`. The str(decimal) was taken from: [simplejson/encoder.py#L511](https://github.com/simplejson/simplejson/blob/8bef979ad8272cbc2903970f4b9992f603d50973/simplejson/encoder.py#L511)  \r\n\r\n```python\r\nfrom flask import json as fjson\r\nfrom flask.json import JSONEncoder\r\nimport simplejson as sjson\r\nimport decimal\r\nfrom datetime import datetime\r\n\r\nrdatetime = datetime.strptime('1/1/2008 1:30 PM', '%m/%d/%Y %I:%M %p')\r\nrdecimal = decimal.Decimal(10)\r\n\r\nobj = {'datetime':rdatetime,'decimal':rdecimal}\r\n\r\nfjson.dumps(obj) #Doesn't work because of decimal\r\nsjson.dumps(obj) #Doesn't work because of datetimes\r\n```  \r\nThe custom encoder:  \r\n```python\r\nclass CustomJSONEncoder(JSONEncoder):\r\n    '''\r\n    Add Decimal coverage\r\n    '''\r\n    def default(self, o):\r\n        if isinstance(o, decimal.Decimal):\r\n            return str(o)\r\n        return super().default(o)\r\n\r\napp.json_encoder = CustomJSONEncoder\r\n```  \r\n\r\nThe expected behavior is to work with both `Decimal` and `datetimes`  as it used to work on Flask version 1.1.2\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.8.10\r\n- Flask version: 2.0.1 and 1.1.2\r\n- Simplejson(Optional) version: 3.17.2\r\n\n", "hints_text": "hey, I'd like to work on this issue. ", "created_at": "2021-06-19T12:01:43Z"}
{"repo": "pallets/flask", "pull_number": 4575, "instance_id": "pallets__flask-4575", "issue_numbers": ["4569"], "base_commit": "bd56d19b167822a9a23e2e9e2a07ccccc36baa8d", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -5,6 +5,9 @@ Version 2.2.0\n \n Unreleased\n \n+-   Add an ``app.redirect`` method, which ``flask.redirect`` will call.\n+    This makes it possible for an app to override how redirects work.\n+    :issue:`4569`\n -   Refactor ``register_error_handler`` to consolidate error checking.\n     Rewrite some error messages to be more consistent. :issue:`4559`\n \ndiff --git a/src/flask/__init__.py b/src/flask/__init__.py\n--- a/src/flask/__init__.py\n+++ b/src/flask/__init__.py\n@@ -1,7 +1,6 @@\n from markupsafe import escape\n from markupsafe import Markup\n from werkzeug.exceptions import abort as abort\n-from werkzeug.utils import redirect as redirect\n \n from . import json as json\n from .app import Flask as Flask\n@@ -23,6 +22,7 @@\n from .helpers import get_flashed_messages as get_flashed_messages\n from .helpers import get_template_attribute as get_template_attribute\n from .helpers import make_response as make_response\n+from .helpers import redirect as redirect\n from .helpers import send_file as send_file\n from .helpers import send_from_directory as send_from_directory\n from .helpers import stream_with_context as stream_with_context\ndiff --git a/src/flask/app.py b/src/flask/app.py\n--- a/src/flask/app.py\n+++ b/src/flask/app.py\n@@ -22,6 +22,7 @@\n from werkzeug.routing import RequestRedirect\n from werkzeug.routing import RoutingException\n from werkzeug.routing import Rule\n+from werkzeug.utils import redirect as _wz_redirect\n from werkzeug.wrappers import Response as BaseResponse\n \n from . import cli\n@@ -1630,6 +1631,16 @@ def async_to_sync(\n \n         return asgiref_async_to_sync(func)\n \n+    def redirect(self, location: str, code: int = 302) -> BaseResponse:\n+        \"\"\"Create a redirect response object.\n+\n+        :param location: the url of the redirect\n+        :param code: http return code\n+\n+        .. versionadded:: 2.2\n+        \"\"\"\n+        return _wz_redirect(location, code=code, Response=self.response_class)\n+\n     def make_response(self, rv: ResponseReturnValue) -> Response:\n         \"\"\"Convert the return value from a view function to an instance of\n         :attr:`response_class`.\ndiff --git a/src/flask/helpers.py b/src/flask/helpers.py\n--- a/src/flask/helpers.py\n+++ b/src/flask/helpers.py\n@@ -12,6 +12,7 @@\n import werkzeug.utils\n from werkzeug.routing import BuildError\n from werkzeug.urls import url_quote\n+from werkzeug.utils import redirect as _wz_redirect\n \n from .globals import _app_ctx_stack\n from .globals import _request_ctx_stack\n@@ -21,6 +22,7 @@\n from .signals import message_flashed\n \n if t.TYPE_CHECKING:  # pragma: no cover\n+    from werkzeug.wrappers import Response as BaseResponse\n     from .wrappers import Response\n \n \n@@ -340,6 +342,28 @@ def external_url_handler(error, endpoint, values):\n     return rv\n \n \n+def redirect(\n+    location: str, code: int = 302, Response: t.Optional[t.Type[\"BaseResponse\"]] = None\n+) -> \"BaseResponse\":\n+    \"\"\"Create a redirect response object.\n+\n+    If :data:`~flask.current_app` is available, it will use\n+    :meth:`~flask.app.Flask.redirect`, otherwise it will use\n+    :func:`werkzeug.utils.redirect`.\n+\n+    :param location: The URL to redirect to.\n+    :param code: The status code for the redirect.\n+    :param Response: The response class to use. Not used when\n+        ``current_app`` is active, which uses ``app.response_class``.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+    if current_app:\n+        return current_app.redirect(location, code=code)\n+\n+    return _wz_redirect(location, code=code, Response=Response)\n+\n+\n def get_template_attribute(template_name: str, attribute: str) -> t.Any:\n     \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n     invoke a macro from within Python code.  If you for example have a\n", "test_patch": "diff --git a/tests/test_helpers.py b/tests/test_helpers.py\n--- a/tests/test_helpers.py\n+++ b/tests/test_helpers.py\n@@ -158,6 +158,22 @@ def post(self):\n         assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"\n \n \n+def test_redirect_no_app():\n+    response = flask.redirect(\"https://localhost\", 307)\n+    assert response.location == \"https://localhost\"\n+    assert response.status_code == 307\n+\n+\n+def test_redirect_with_app(app):\n+    def redirect(location, code=302):\n+        raise ValueError\n+\n+    app.redirect = redirect\n+\n+    with app.app_context(), pytest.raises(ValueError):\n+        flask.redirect(\"other\")\n+\n+\n class TestNoImports:\n     \"\"\"Test Flasks are created without import.\n \n", "problem_statement": "Move `redirect` to the `Flask` app object\nAdd a `redirect` method to the `Flask` app object. Similar to functions like `flask.json.dumps`, `flask.redirect` should look for a `current_app` and call its `redirect` method. This will allow applications to override the redirect behavior.\n", "hints_text": "I'm at the sprint and will start on this.", "created_at": "2022-05-02T16:46:41Z"}
{"repo": "pallets/flask", "pull_number": 5014, "instance_id": "pallets__flask-5014", "issue_numbers": ["5010"], "base_commit": "7ee9ceb71e868944a46e1ff00b506772a53a4f1d", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -35,6 +35,8 @@ Unreleased\n -   Ensure subdomains are applied with nested blueprints. :issue:`4834`\n -   ``config.from_file`` can use ``text=False`` to indicate that the parser wants a\n     binary file instead. :issue:`4989`\n+-   If a blueprint is created with an empty name it raises a ``ValueError``.\n+    :issue:`5010`\n \n \n Version 2.2.4\ndiff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -190,6 +190,9 @@ def __init__(\n             root_path=root_path,\n         )\n \n+        if not name:\n+            raise ValueError(\"'name' may not be empty.\")\n+\n         if \".\" in name:\n             raise ValueError(\"'name' may not contain a dot '.' character.\")\n \n", "test_patch": "diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -256,6 +256,11 @@ def test_dotted_name_not_allowed(app, client):\n         flask.Blueprint(\"app.ui\", __name__)\n \n \n+def test_empty_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"\", __name__)\n+\n+\n def test_dotted_names_from_app(app, client):\n     test = flask.Blueprint(\"test\", __name__)\n \n", "problem_statement": "Require a non-empty name for Blueprints\nThings do not work correctly if a Blueprint is given an empty name (e.g. #4944).\r\nIt would be helpful if a `ValueError` was raised when trying to do that.\n", "hints_text": "", "created_at": "2023-03-04T18:36:21Z"}
{"repo": "pallets/flask", "pull_number": 4169, "instance_id": "pallets__flask-4169", "issue_numbers": ["4096"], "base_commit": "66d9d4fa8d07dd50e4cb3036a9ae5f92c4693b84", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -17,6 +17,8 @@ Unreleased\n     :issue:`4150`\n -   ``jsonify`` handles ``decimal.Decimal`` by encoding to ``str``.\n     :issue:`4157`\n+-   Correctly handle raising deferred errors in CLI lazy loading.\n+    :issue:`4096`\n \n \n Version 2.0.1\ndiff --git a/src/flask/cli.py b/src/flask/cli.py\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -312,7 +312,7 @@ def __init__(self, loader, use_eager_loading=None):\n         self.loader = loader\n         self._app = None\n         self._lock = Lock()\n-        self._bg_loading_exc_info = None\n+        self._bg_loading_exc = None\n \n         if use_eager_loading is None:\n             use_eager_loading = os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\"\n@@ -328,23 +328,24 @@ def _load_app():\n             with self._lock:\n                 try:\n                     self._load_unlocked()\n-                except Exception:\n-                    self._bg_loading_exc_info = sys.exc_info()\n+                except Exception as e:\n+                    self._bg_loading_exc = e\n \n         t = Thread(target=_load_app, args=())\n         t.start()\n \n     def _flush_bg_loading_exception(self):\n         __traceback_hide__ = True  # noqa: F841\n-        exc_info = self._bg_loading_exc_info\n-        if exc_info is not None:\n-            self._bg_loading_exc_info = None\n-            raise exc_info\n+        exc = self._bg_loading_exc\n+\n+        if exc is not None:\n+            self._bg_loading_exc = None\n+            raise exc\n \n     def _load_unlocked(self):\n         __traceback_hide__ = True  # noqa: F841\n         self._app = rv = self.loader()\n-        self._bg_loading_exc_info = None\n+        self._bg_loading_exc = None\n         return rv\n \n     def __call__(self, environ, start_response):\n", "test_patch": "diff --git a/tests/test_cli.py b/tests/test_cli.py\n--- a/tests/test_cli.py\n+++ b/tests/test_cli.py\n@@ -17,6 +17,7 @@\n from flask import current_app\n from flask import Flask\n from flask.cli import AppGroup\n+from flask.cli import DispatchingApp\n from flask.cli import dotenv\n from flask.cli import find_best_app\n from flask.cli import FlaskGroup\n@@ -310,6 +311,23 @@ def create_app():\n     assert app.name == \"testapp\"\n \n \n+def test_lazy_load_error(monkeypatch):\n+    \"\"\"When using lazy loading, the correct exception should be\n+    re-raised.\n+    \"\"\"\n+\n+    class BadExc(Exception):\n+        pass\n+\n+    def bad_load():\n+        raise BadExc\n+\n+    lazy = DispatchingApp(bad_load, use_eager_loading=False)\n+\n+    with pytest.raises(BadExc):\n+        lazy._flush_bg_loading_exception()\n+\n+\n def test_with_appcontext(runner):\n     @click.command()\n     @with_appcontext\n", "problem_statement": "Exceptions are sometimes replaced with \"TypeError: exceptions must derive from BaseException\"\n```python\r\n# a.py\r\ndef create_app(): raise RuntimeError()\r\n```\r\n```\r\n$ FLASK_APP=a.py flask run --lazy-loading\r\n$ curl http://127.0.0.1:5000\r\n[...]\r\nTraceback (most recent call last):\r\n  File \"[...]/lib/python3.9/site-packages/flask/cli.py\", line 356, in __call__\r\n    self._flush_bg_loading_exception()\r\n  File \"[...]/lib/python3.9/site-packages/flask/cli.py\", line 344, in _flush_bg_loading_exception\r\n    raise exc_info\r\nTypeError: exceptions must derive from BaseException\r\n```\r\n\r\nI expected something about a RuntimeError.  `raise exc_info[1]` here worked for me https://github.com/pallets/flask/blob/7161776824734fc2797fe2b4fc974d183487ebf8/src/flask/cli.py#L342\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9.5\r\n- Flask version: 2.0.1\r\n\n", "hints_text": "I am seeing this too. I just started a new flask project.\nfor me it was because i had the same function names for the same endpoint", "created_at": "2021-06-22T23:57:43Z"}
{"repo": "pallets/flask", "pull_number": 4992, "instance_id": "pallets__flask-4992", "issue_numbers": ["4989"], "base_commit": "4c288bc97ea371817199908d0d9b12de9dae327e", "patch": "diff --git a/CHANGES.rst b/CHANGES.rst\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -33,6 +33,8 @@ Unreleased\n -   Use modern packaging metadata with ``pyproject.toml`` instead of ``setup.cfg``.\n     :pr:`4947`\n -   Ensure subdomains are applied with nested blueprints. :issue:`4834`\n+-   ``config.from_file`` can use ``text=False`` to indicate that the parser wants a\n+    binary file instead. :issue:`4989`\n \n \n Version 2.2.3\ndiff --git a/src/flask/config.py b/src/flask/config.py\n--- a/src/flask/config.py\n+++ b/src/flask/config.py\n@@ -234,6 +234,7 @@ def from_file(\n         filename: str,\n         load: t.Callable[[t.IO[t.Any]], t.Mapping],\n         silent: bool = False,\n+        text: bool = True,\n     ) -> bool:\n         \"\"\"Update the values in the config from a file that is loaded\n         using the ``load`` parameter. The loaded data is passed to the\n@@ -244,8 +245,8 @@ def from_file(\n             import json\n             app.config.from_file(\"config.json\", load=json.load)\n \n-            import toml\n-            app.config.from_file(\"config.toml\", load=toml.load)\n+            import tomllib\n+            app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n \n         :param filename: The path to the data file. This can be an\n             absolute path or relative to the config root path.\n@@ -254,14 +255,18 @@ def from_file(\n         :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n             implements a ``read`` method.\n         :param silent: Ignore the file if it doesn't exist.\n+        :param text: Open the file in text or binary mode.\n         :return: ``True`` if the file was loaded successfully.\n \n+        .. versionchanged:: 2.3\n+            The ``text`` parameter was added.\n+\n         .. versionadded:: 2.0\n         \"\"\"\n         filename = os.path.join(self.root_path, filename)\n \n         try:\n-            with open(filename) as f:\n+            with open(filename, \"r\" if text else \"rb\") as f:\n                 obj = load(f)\n         except OSError as e:\n             if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n", "test_patch": "diff --git a/tests/static/config.toml b/tests/static/config.toml\nnew file mode 100644\n--- /dev/null\n+++ b/tests/static/config.toml\n@@ -0,0 +1,2 @@\n+TEST_KEY=\"foo\"\n+SECRET_KEY=\"config\"\ndiff --git a/tests/test_config.py b/tests/test_config.py\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -6,7 +6,6 @@\n \n import flask\n \n-\n # config keys used for the TestConfig\n TEST_KEY = \"foo\"\n SECRET_KEY = \"config\"\n@@ -30,13 +29,23 @@ def test_config_from_object():\n     common_object_test(app)\n \n \n-def test_config_from_file():\n+def test_config_from_file_json():\n     app = flask.Flask(__name__)\n     current_dir = os.path.dirname(os.path.abspath(__file__))\n     app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n     common_object_test(app)\n \n \n+def test_config_from_file_toml():\n+    tomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\n+    app = flask.Flask(__name__)\n+    current_dir = os.path.dirname(os.path.abspath(__file__))\n+    app.config.from_file(\n+        os.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, text=False\n+    )\n+    common_object_test(app)\n+\n+\n def test_from_prefixed_env(monkeypatch):\n     monkeypatch.setenv(\"FLASK_STRING\", \"value\")\n     monkeypatch.setenv(\"FLASK_BOOL\", \"true\")\n", "problem_statement": "Add a file mode parameter to flask.Config.from_file()\nPython 3.11 introduced native TOML support with the `tomllib` package. This could work nicely with the `flask.Config.from_file()` method as an easy way to load TOML config files:\r\n\r\n```python\r\napp.config.from_file(\"config.toml\", tomllib.load)\r\n```\r\n\r\nHowever, `tomllib.load()` takes an object readable in binary mode, while `flask.Config.from_file()` opens a file in text mode, resulting in this error:\r\n\r\n```\r\nTypeError: File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\r\n```\r\n\r\nWe can get around this with a more verbose expression, like loading from a file opened with the built-in `open()` function and passing the `dict` to `app.Config.from_mapping()`:\r\n\r\n```python\r\n# We have to repeat the path joining that from_file() does\r\nwith open(os.path.join(app.config.root_path, \"config.toml\"), \"rb\") as file:\r\n    app.config.from_mapping(tomllib.load(file))\r\n```\r\n\r\nBut adding a file mode parameter to `flask.Config.from_file()` would enable the use of a simpler expression. E.g.:\r\n\r\n```python\r\napp.config.from_file(\"config.toml\", tomllib.load, mode=\"b\")\r\n```\r\n\n", "hints_text": "You can also use:\r\n\r\n```python\r\napp.config.from_file(\"config.toml\", lambda f: tomllib.load(f.buffer))\r\n```\nThanks - I was looking for another way to do it. I'm happy with that for now, although it's worth noting this about `io.TextIOBase.buffer` from the docs:\r\n\r\n> This is not part of the [TextIOBase](https://docs.python.org/3/library/io.html#io.TextIOBase) API and may not exist in some implementations.\nOh, didn't mean for you to close this, that was just a shorter workaround. I think a `text=True` parameter would be better, easier to use `True` or `False` rather than mode strings. Some libraries, like `tomllib`, have _Opinions_ about whether text or bytes are correct for parsing files, and we can accommodate that.\ncan i work on this?\nNo need to ask to work on an issue. As long as the issue is not assigned to anyone and doesn't have have a linked open PR (both can be seen in the sidebar), anyone is welcome to work on any issue.", "created_at": "2023-02-22T14:00:17Z"}
